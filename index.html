<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balanço de Massa: Curva Unificada</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body class="bg-gray-50 p-4 font-sans text-gray-800 flex flex-col min-h-screen">

    <div class="max-w-7xl mx-auto bg-white p-6 rounded-xl shadow-lg border border-gray-100 flex-grow w-full">
        
        <!-- Header -->
        <div class="flex flex-col md:flex-row justify-between items-start mb-6 border-b border-gray-100 pb-4">
            <div>
                <h1 class="text-2xl font-bold text-gray-800">Secagem 134-FR-004 | Projeção de Nível de GLP</h1>
                 <p class="text-gray-500 text-sm mt-1">
                    Projeção Contínua de Nível Tanque GLP (3x4.000kg = 12.000kg)
                </p>
                <p class="text-gray-500 text-sm mt-1">
                    Dados atualizados até <span class="font-bold text-blue-600">30/11 10:30</span>.
                </p>
            </div>
            
            <div id="status-panel" class="mt-4 md:mt-0 px-4 py-2 rounded-lg bg-gray-100 text-right">
                <div class="text-xs text-gray-500 uppercase font-semibold">Status Final (120h)</div>
                <div id="system-end-status" class="text-xl font-bold text-gray-700">Calculando...</div>
            </div>
        </div>

        <!-- Painel de Equação -->
        <div class="mb-6 bg-slate-50 border border-slate-200 p-3 rounded-lg flex flex-col md:flex-row items-center justify-between gap-4 text-sm font-mono text-slate-700">
            <div class="flex items-center gap-2">
                <i class="fas fa-calculator text-slate-400"></i>
                <span class="font-bold uppercase text-xs text-slate-500">Cálculo Instantâneo:</span>
            </div>
            <div class="flex flex-wrap items-center gap-2 bg-white px-3 py-1 rounded border border-slate-200 shadow-sm text-xs md:text-sm">
                <span>Total(t) = [</span>
                <span class="text-blue-600 font-bold" title="Carga Base Fixa">Base(<span id="eq-base">--</span>)</span>
                <span>+</span>
                <span class="text-orange-600 font-bold" title="Consumo Variável do Forno">Forno(<span id="eq-temp">--</span>°C)</span>
                <span>] ×</span>
                <span class="text-purple-600 font-bold" title="Fator Total Definido no Slider">Fator(<span id="eq-factor">--</span>%)</span>
            </div>
        </div>

        <!-- Controles -->
        <div class="mb-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            
            <!-- 1. Abastecimento -->
            <div class="bg-indigo-50 border border-indigo-100 p-4 rounded-lg flex flex-col gap-2">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm font-bold text-indigo-900"><i class="fas fa-gas-pump mr-1"></i> Planejar Recargas</span>
                    <div class="relative inline-block w-10 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="auto-refill-toggle" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-gray-300"/>
                        <label for="auto-refill-toggle" class="toggle-label block overflow-hidden h-5 rounded-full bg-gray-300 cursor-pointer"></label>
                    </div>
                </div>
                <div class="flex items-center gap-2 opacity-50 transition-opacity" id="slider-container">
                    <input type="range" id="refill-interval" min="12" max="120" value="48" step="4" class="w-full h-1 bg-indigo-200 rounded-lg appearance-none cursor-pointer">
                    <span id="interval-display" class="text-xs font-bold text-indigo-700 bg-white px-2 py-1 rounded border border-indigo-200">48h</span>
                </div>
                <div class="text-[10px] text-indigo-400 mt-1">
                    *Intervalos a partir da última recarga confirmada
                </div>
            </div>

            <!-- 2. Ajuste de Consumo -->
            <div class="bg-purple-50 border border-purple-100 p-4 rounded-lg flex flex-col gap-2">
                <div class="flex items-center justify-between mb-1">
                    <span class="text-sm font-bold text-purple-900"><i class="fas fa-tachometer-alt mr-1"></i> Fator de Carga Total</span>
                    <span id="consumption-display" class="text-xs font-bold text-white bg-purple-600 px-2 py-1 rounded shadow-sm">+15%</span>
                </div>
                <!-- Slider de 80% a 150% -->
                <input type="range" id="consumption-factor" min="80" max="150" value="115" step="5" class="w-full h-1 bg-purple-200 rounded-lg appearance-none cursor-pointer accent-purple-600">
                <div class="flex justify-between text-[10px] text-purple-600 font-semibold px-1">
                    <span>-20% (Otimista)</span>
                    <span>0% (Padrão)</span>
                    <span>+50% (Crítico)</span>
                </div>
            </div>

            <!-- 3. Visualização (Individual vs Unificado) -->
            <div class="bg-teal-50 border border-teal-100 p-4 rounded-lg flex flex-col justify-center gap-2">
                <span class="text-sm font-bold text-teal-900"><i class="fas fa-layer-group mr-1"></i> Modo de Visualização</span>
                <div class="flex bg-teal-200 rounded p-1">
                    <button id="btn-view-unified" class="flex-1 py-1 px-2 rounded text-xs font-bold shadow bg-white text-teal-700 transition-all">
                        Unificado (Total)
                    </button>
                    <button id="btn-view-individual" class="flex-1 py-1 px-2 rounded text-xs font-bold text-teal-600 hover:bg-teal-100 transition-all">
                        Individual (TQ)
                    </button>
                </div>
            </div>

            <!-- 4. Unidade -->
            <div class="bg-gray-50 border border-gray-200 p-4 rounded-lg flex flex-col justify-center gap-2">
                <span class="text-sm font-bold text-gray-700"><i class="fas fa-ruler-vertical mr-1"></i> Unidade Eixo Y</span>
                <div class="flex bg-gray-200 rounded p-1">
                    <button id="btn-unit-pct" class="flex-1 py-1 px-3 rounded text-sm font-bold shadow bg-white text-indigo-600 transition-all">
                        % Nível
                    </button>
                    <button id="btn-unit-kg" class="flex-1 py-1 px-3 rounded text-sm font-bold text-gray-500 hover:bg-gray-100 transition-all">
                        kg Massa
                    </button>
                </div>
            </div>
        </div>

        <style>
            .toggle-checkbox:checked { right: 0; border-color: #4f46e5; }
            .toggle-checkbox:checked + .toggle-label { background-color: #4f46e5; }
            .toggle-checkbox { right: 0; transition: all 0.3s; right: 50%; }
            .toggle-label { width: 2.5rem; }
        </style>

        <div class="flex flex-col lg:flex-row gap-6 mb-8">
            <!-- Gráfico Principal -->
            <div class="w-full lg:w-3/4 h-[450px] relative border rounded-lg p-2 shadow-sm">
                <canvas id="mainChart"></canvas>
            </div>
            
            <!-- Painel Info Lateral -->
            <div class="w-full lg:w-1/4 flex flex-col gap-4">
                
                <div class="bg-orange-50 p-4 rounded-lg border border-orange-100">
                    <h3 class="text-orange-900 font-bold mb-2 text-xs uppercase">Monitoramento Atual</h3>
                    <div class="space-y-2">
                        <div class="flex justify-between">
                            <span class="text-sm text-orange-800">Fase Atual:</span>
                            <span id="phase-name" class="text-sm font-bold text-orange-900 text-right">--</span>
                        </div>
                        <div class="flex justify-between items-center border-t border-orange-200 pt-2">
                            <span class="text-xs text-orange-700">Temp Forno:</span>
                            <span id="oven-temp" class="text-2xl font-bold text-orange-600">--°C</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-orange-700">Taxa Estimada:</span>
                            <span id="total-load" class="text-lg font-bold text-purple-700">-- kg/h</span>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-50 p-3 rounded text-xs text-gray-500 space-y-2" id="legend-container">
                    <!-- Legenda Dinâmica -->
                </div>
            </div>
        </div>

        <!-- Tabela de Dados (Rodapé) -->
        <div class="border border-gray-200 rounded-lg overflow-hidden bg-white shadow-sm mt-6">
            <div class="bg-gray-100 px-4 py-3 border-b border-gray-200 flex justify-between items-center">
                <div>
                    <h3 class="font-bold text-gray-700 text-sm">Registro de Leituras</h3>
                    <p class="text-xs text-gray-500">Os deltas de consumo entre leituras normais alimentam o cálculo da Base.</p>
                </div>
                <div class="flex gap-2">
                    <button onclick="addRow()" class="text-xs bg-white border border-gray-300 text-gray-700 px-3 py-1 rounded hover:bg-gray-50">+ Leitura</button>
                    <button onclick="updateModel()" class="text-xs bg-indigo-600 text-white px-3 py-1 rounded hover:bg-indigo-700 shadow-sm font-bold">Recalcular</button>
                </div>
            </div>
            <div class="max-h-80 overflow-y-auto">
                <table class="min-w-full text-sm">
                    <thead class="bg-gray-50 text-xs text-gray-500 uppercase sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th class="px-4 py-2 text-left">Data/Hora (24h)</th>
                            <th class="px-2 py-2 text-center w-24 text-blue-600">TQ1 (%)</th>
                            <th class="px-2 py-2 text-center w-24 text-orange-600">TQ2 (%)</th>
                            <th class="px-2 py-2 text-center w-24 text-teal-600">TQ3 (%)</th>
                            <th class="px-4 py-2 text-right">Total (kg)</th>
                            <th class="px-2 py-2 text-center w-24 text-green-700" title="É Abastecimento?"><i class="fas fa-gas-pump"></i></th>
                            <th class="px-2 py-2 w-10"></th>
                        </tr>
                    </thead>
                    <tbody id="editable-table-body" class="bg-white divide-y divide-gray-100">
                        <!-- JS Populated -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Painel de Equação (Movido para baixo) -->
        <div class="mt-6 bg-slate-50 border border-slate-200 p-3 rounded-lg flex flex-col md:flex-row items-center justify-between gap-4 text-sm font-mono text-slate-700">
            <div class="flex items-center gap-2">
                <i class="fas fa-calculator text-slate-400"></i>
                <span class="font-bold uppercase text-xs text-slate-500">Cálculo Instantâneo:</span>
            </div>
            <div class="flex flex-wrap items-center gap-2 bg-white px-3 py-1 rounded border border-slate-200 shadow-sm text-xs md:text-sm">
                <span>Total(t) = [</span>
                <span class="text-blue-600 font-bold" title="Carga Base Fixa">Base(<span id="eq-base">--</span>)</span>
                <span>+</span>
                <span class="text-orange-600 font-bold" title="Consumo Variável do Forno">Forno(<span id="eq-temp">--</span>°C)</span>
                <span>] ×</span>
                <span class="text-purple-600 font-bold" title="Fator Total Definido no Slider">Fator(<span id="eq-factor">--</span>%)</span>
            </div>
        </div>

    </div>
    
    <!-- Assinatura -->
    <div class="text-center py-4 text-xs text-gray-300 font-mono">
        Henrique Melo
    </div>

    <script>
        // --- 1. REGISTRAR POSICIONADOR DE TOOLTIP PERSONALIZADO ---
        Chart.Tooltip.positioners.followMouse = function(elements, eventPosition) {
            if (!elements.length) return false;
            return {
                x: elements[0].element.x,
                y: eventPosition.y
            };
        };

        // --- CONSTANTES ---
        const TANK_CAPACITY_SINGLE = 4000; 
        const TOTAL_CAPACITY = 12000;
        const SAFETY_LIMIT_PERCENT = 10;
        const REFILL_LEVEL_PERCENT = 85;

        // --- ESTADO ---
        let currentUnit = 'pct';
        let viewMode = 'unified'; // 'unified' or 'individual'
        let myChart = null;
        
        // Dados Iniciais
        let rawData = [
            { time: '2025-11-26T19:00', tq1: 33, tq2: 30, tq3: 40, isRefill: false }, 
            { time: '2025-11-26T22:00', tq1: 32, tq2: 29, tq3: 38, isRefill: false }, 
            { time: '2025-11-27T00:00', tq1: 85, tq2: 85, tq3: 85, isRefill: true }, 
            { time: '2025-11-27T05:00', tq1: 61, tq2: 75, tq3: 83, isRefill: false },
            { time: '2025-11-27T10:00', tq1: 61, tq2: 69, tq3: 82, isRefill: false },
            { time: '2025-11-27T16:00', tq1: 64, tq2: 64, tq3: 78, isRefill: false },
            { time: '2025-11-28T03:00', tq1: 56, tq2: 54, tq3: 67, isRefill: false },
            { time: '2025-11-28T09:00', tq1: 85, tq2: 85, tq3: 85, isRefill: true },
            { time: '2025-11-28T15:00', tq1: 76, tq2: 80, tq3: 85, isRefill: false },
            { time: '2025-11-29T14:00', tq1: 56, tq2: 52, tq3: 80, isRefill: false },
            { time: '2025-11-29T18:00', tq1: 85, tq2: 85, tq3: 85, isRefill: true },
            { time: '2025-11-30T10:30', tq1: 65, tq2: 56, tq3: 85, isRefill: false }
        ];

        let realHistory = [];
        let pLastReal = null;
        let BASE_LOAD_KG_H = 0;
        let lastRefillTimestamp = null;

        // --- TEMPO ---
        const BAKE_START_STR = '2025-11-26T16:00:00';
        const bakeStartMs = new Date(BAKE_START_STR).getTime();
        const SIMULATION_DURATION_HOURS = 125; 
        const simEndMs = bakeStartMs + (SIMULATION_DURATION_HOURS * 3600000);

        // --- HELPERS DE FORMATAÇÃO ---
        function isoToDisplay(iso) {
            if (!iso) return "";
            try {
                const [date, time] = iso.split('T');
                const [y, m, d] = date.split('-');
                return `${d}/${m}/${y} ${time}`;
            } catch (e) { return iso; }
        }

        function displayToIso(display) {
            try {
                const [datePart, timePart] = display.split(' ');
                const [d, m, y] = datePart.split('/');
                if (d && m && y && timePart) {
                    return `${y}-${m}-${d}T${timePart}`;
                }
            } catch(e) {}
            return display; 
        }

        // --- MODELO FÍSICO COM INTERPOLAÇÃO ---
        const ovenConsPoints = [
            { temp: 25,  kg: 5 },  
            { temp: 120, kg: 15 },
            { temp: 245, kg: 27 },
            { temp: 360, kg: 40 },
            { temp: 540, kg: 60 },
            { temp: 700, kg: 80 }
        ];

        function getOvenConsumption(temp) {
            for (let i = 0; i < ovenConsPoints.length - 1; i++) {
                let p1 = ovenConsPoints[i];
                let p2 = ovenConsPoints[i+1];
                if (temp >= p1.temp && temp <= p2.temp) {
                    return p1.kg + (temp - p1.temp) * (p2.kg - p1.kg) / (p2.temp - p1.temp);
                }
            }
            if (temp > 700) return 80;
            return 5;
        }

        const curvePhases = [
            { name: "Rampa 120°C", duration: 6.33, endTemp: 120, type: 'ramp' },
            { name: "Patamar 120°C (24h)", duration: 24, endTemp: 120, type: 'hold' },
            { name: "Rampa 245°C", duration: 8.33, endTemp: 245, type: 'ramp' },
            { name: "Patamar 245°C (20h)", duration: 20, endTemp: 245, type: 'hold' },
            { name: "Rampa 360°C", duration: 7.66, endTemp: 360, type: 'ramp' },
            { name: "Patamar 360°C (20h)", duration: 20, endTemp: 360, type: 'hold' },
            { name: "Rampa 540°C", duration: 7.2, endTemp: 540, type: 'ramp' },
            { name: "Patamar 540°C (20h)", duration: 20, endTemp: 540, type: 'hold' },
            { name: "Rampa 700°C", duration: 6.4, endTemp: 700, type: 'ramp' },
            { name: "Operação 700°C", duration: 10, endTemp: 700, type: 'hold' }
        ];

        function getCurveState(timestamp) {
            let elapsedHours = (timestamp - bakeStartMs) / 3600000;
            if (elapsedHours < 0) return { temp: 25, phase: "Pré-ignição" };
            let temp = 25;
            let timeAcc = 0;
            for (let phase of curvePhases) {
                if (elapsedHours <= timeAcc + phase.duration) {
                    let timeInPhase = elapsedHours - timeAcc;
                    if (phase.type === 'ramp') {
                        let progress = timeInPhase / phase.duration;
                        temp = temp + (phase.endTemp - temp) * progress;
                    } else {
                        temp = phase.endTemp;
                    }
                    return { temp: temp, phase: phase.name, type: phase.type };
                }
                temp = phase.endTemp;
                timeAcc += phase.duration;
            }
            return { temp: 700, phase: "Operação", type: 'hold' };
        }

        // --- LÓGICA DE DADOS & CALIBRAÇÃO ---
        function recalculateModel() {
            rawData.sort((a, b) => new Date(a.time) - new Date(b.time));

            realHistory = rawData.map(point => {
                let mass = ((point.tq1 + point.tq2 + point.tq3) / 300) * TOTAL_CAPACITY;
                let pct = (mass / TOTAL_CAPACITY) * 100;
                return { 
                    time: point.time, 
                    ts: new Date(point.time).getTime(), 
                    pct: pct, 
                    mass: mass,
                    isRefill: point.isRefill,
                    raw: point // Access to raw tq1, tq2, tq3
                };
            });

            pLastReal = realHistory[realHistory.length - 1];

            // Ultimo refill para projeção
            let foundRefill = null;
            for(let i = realHistory.length-1; i >= 0; i--) {
                if(realHistory[i].isRefill) { foundRefill = realHistory[i]; break; }
            }
            lastRefillTimestamp = foundRefill ? foundRefill.ts : realHistory[0].ts;

            // Integração de Consumo
            let totalWeightedBaseLoad = 0;
            let totalDurationHours = 0;

            for (let i = 0; i < realHistory.length - 1; i++) {
                let pCurrent = realHistory[i];
                let pNext = realHistory[i+1];
                if (pNext.isRefill) continue;

                let hours = (pNext.ts - pCurrent.ts) / 3600000;
                let massDiff = pCurrent.mass - pNext.mass; 

                if (massDiff > 0 && hours > 0) {
                    let realRate = massDiff / hours; 
                    let midTime = (pCurrent.ts + pNext.ts) / 2;
                    let state = getCurveState(midTime);
                    let theoreticalOven = getOvenConsumption(state.temp);
                    let intervalBaseLoad = Math.max(0, realRate - theoreticalOven);

                    totalWeightedBaseLoad += intervalBaseLoad * hours;
                    totalDurationHours += hours;
                }
            }

            if (totalDurationHours > 0) {
                BASE_LOAD_KG_H = totalWeightedBaseLoad / totalDurationHours;
            } else {
                BASE_LOAD_KG_H = 0; 
            }
        }

        // --- GERENCIAMENTO DA TABELA ---
        function renderEditableTable() {
            const tbody = document.getElementById('editable-table-body');
            tbody.innerHTML = '';
            
            rawData.forEach((row, index) => {
                let avgPct = Math.round((row.tq1+row.tq2+row.tq3)/3);
                let totalKg = Math.round(((row.tq1+row.tq2+row.tq3)/300)*TOTAL_CAPACITY);
                const isChecked = row.isRefill ? 'checked' : '';
                const displayTime = isoToDisplay(row.time);
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="px-4 py-2">
                        <input type="text" value="${displayTime}" onchange="updateRow(${index}, 'time', this.value)" class="text-xs border rounded p-1 w-full bg-gray-50 focus:bg-white outline-none font-mono placeholder-gray-300" placeholder="DD/MM/AAAA HH:MM">
                    </td>
                    <td class="px-2 py-2">
                        <input type="number" min="0" max="100" value="${row.tq1}" onchange="updateRow(${index}, 'tq1', this.value)" class="text-xs text-center font-bold text-blue-600 border rounded p-1 w-full bg-gray-50 focus:bg-white">
                    </td>
                    <td class="px-2 py-2">
                        <input type="number" min="0" max="100" value="${row.tq2}" onchange="updateRow(${index}, 'tq2', this.value)" class="text-xs text-center font-bold text-orange-600 border rounded p-1 w-full bg-gray-50 focus:bg-white">
                    </td>
                    <td class="px-2 py-2">
                        <input type="number" min="0" max="100" value="${row.tq3}" onchange="updateRow(${index}, 'tq3', this.value)" class="text-xs text-center font-bold text-teal-600 border rounded p-1 w-full bg-gray-50 focus:bg-white">
                    </td>
                    <td class="px-4 py-2 text-right font-mono text-gray-600 text-xs">
                        ${totalKg} kg
                    </td>
                    <td class="px-2 py-2 text-center">
                        <input type="checkbox" ${isChecked} onchange="updateRow(${index}, 'isRefill', this.checked)" class="w-4 h-4 text-green-600 rounded border-gray-300 focus:ring-green-500 cursor-pointer">
                    </td>
                    <td class="px-2 py-2 text-center">
                        <button onclick="removeRow(${index})" class="text-red-400 hover:text-red-700 text-xs font-bold">×</button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        window.updateRow = function(index, field, value) {
            if (field === 'time') { 
                rawData[index][field] = displayToIso(value); 
            } 
            else if (field === 'isRefill') { rawData[index][field] = value; }
            else { rawData[index][field] = parseFloat(value); }
        };

        window.addRow = function() {
            const last = rawData[rawData.length-1];
            let newTime = new Date(new Date(last.time).getTime() + 3600000);
            let timeStr = newTime.toISOString().slice(0,16); // ISO
            rawData.push({ time: timeStr, tq1: last.tq1, tq2: last.tq2, tq3: last.tq3, isRefill: false });
            renderEditableTable();
        };

        window.removeRow = function(index) {
            if(rawData.length > 1) { rawData.splice(index, 1); renderEditableTable(); } 
            else { alert("Mínimo 1 ponto necessário."); }
        };

        window.updateModel = function() {
            recalculateModel();
            renderEditableTable(); 
            runSimulation();
        };

        // --- UI HANDLERS ---
        const toggleEl = document.getElementById('auto-refill-toggle');
        const sliderInterval = document.getElementById('refill-interval');
        const sliderConsumption = document.getElementById('consumption-factor');
        const btnPct = document.getElementById('btn-unit-pct');
        const btnKg = document.getElementById('btn-unit-kg');
        const btnViewUnified = document.getElementById('btn-view-unified');
        const btnViewIndividual = document.getElementById('btn-view-individual');

        toggleEl.addEventListener('change', runSimulation);
        sliderInterval.addEventListener('input', (e) => {
            document.getElementById('interval-display').innerText = e.target.value + "h";
            runSimulation();
        });
        
        sliderConsumption.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            const pctFrom100 = Math.round(val - 100);
            const signal = pctFrom100 > 0 ? "+" : "";
            const text = pctFrom100 === 0 ? "Normal (0%)" : `${signal}${pctFrom100}%`;
            
            const display = document.getElementById('consumption-display');
            if(pctFrom100 > 0) display.className = "text-xs font-bold text-red-700 bg-red-50 px-2 py-1 rounded border border-red-200";
            else if (pctFrom100 < 0) display.className = "text-xs font-bold text-green-700 bg-green-50 px-2 py-1 rounded border border-green-200";
            else display.className = "text-xs font-bold text-orange-700 bg-white px-2 py-1 rounded border border-orange-200";
            
            display.innerText = text;
            runSimulation();
        });

        const setUnit = (unit) => {
            currentUnit = unit;
            if (unit === 'pct') {
                btnPct.className = "flex-1 py-1 px-3 rounded text-sm font-bold shadow bg-white text-indigo-600 transition-all";
                btnKg.className = "flex-1 py-1 px-3 rounded text-sm font-bold text-gray-500 hover:bg-gray-100 transition-all";
            } else {
                btnKg.className = "flex-1 py-1 px-3 rounded text-sm font-bold shadow bg-white text-indigo-600 transition-all";
                btnPct.className = "flex-1 py-1 px-3 rounded text-sm font-bold text-gray-500 hover:bg-gray-100 transition-all";
            }
            runSimulation();
        }
        btnPct.onclick = () => setUnit('pct');
        btnKg.onclick = () => setUnit('kg');

        const setViewMode = (mode) => {
            viewMode = mode;
            if (mode === 'unified') {
                btnViewUnified.className = "flex-1 py-1 px-2 rounded text-xs font-bold shadow bg-white text-teal-700 transition-all";
                btnViewIndividual.className = "flex-1 py-1 px-2 rounded text-xs font-bold text-teal-600 hover:bg-teal-100 transition-all";
            } else {
                btnViewIndividual.className = "flex-1 py-1 px-2 rounded text-xs font-bold shadow bg-white text-teal-700 transition-all";
                btnViewUnified.className = "flex-1 py-1 px-2 rounded text-xs font-bold text-teal-600 hover:bg-teal-100 transition-all";
            }
            updateLegend();
            runSimulation();
        }
        btnViewUnified.onclick = () => setViewMode('unified');
        btnViewIndividual.onclick = () => setViewMode('individual');

        function updateLegend() {
            const container = document.getElementById('legend-container');
            if (viewMode === 'unified') {
                container.innerHTML = `
                    <div class="font-bold text-gray-400 uppercase text-[10px] mb-1">Legenda</div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-blue-600"></div><span>Histórico Real</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-0.5 bg-blue-500 border-t border-dashed"></div><span>Projeção Passada</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-0.5 bg-indigo-500 border-t border-dashed"></div><span>Projeção Futura</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-4 bg-red-50 border border-red-200"></div><span>Curva Temp</span></div>
                `;
            } else {
                container.innerHTML = `
                    <div class="font-bold text-gray-400 uppercase text-[10px] mb-1">Legenda</div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-blue-600"></div><span>TQ1</span></div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-orange-600"></div><span>TQ2</span></div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-teal-600"></div><span>TQ3</span></div>
                    <div class="flex items-center gap-2"><div class="w-4 h-0.5 border-t border-dashed border-gray-400"></div><span>Projeção</span></div>
                `;
            }
        }

        // --- SIMULAÇÃO ---
        function runSimulation() {
            const isAutoRefill = toggleEl.checked;
            const refillIntervalMs = parseInt(sliderInterval.value) * 3600000;
            const consumptionPercentInput = parseFloat(sliderConsumption.value); 
            const totalFactor = consumptionPercentInput / 100; 
            const isKg = currentUnit === 'kg';
            const isIndiv = viewMode === 'individual';

            const series = { 
                real: [], projected: [], temp: [], markers: [], refillMarkers: [], simulatedDrops: [],
                // Arrays for individual tanks
                real1: [], real2: [], real3: [],
                proj1: [], proj2: [], proj3: [],
                simDrops1: [], simDrops2: [], simDrops3: [],
                markers1: [], markers2: [], markers3: [],
                refillMarkers1: [], refillMarkers2: [], refillMarkers3: []
            };
            const stepMs = 10 * 60000;

            // 1. Temp Background
            for(let t = bakeStartMs; t <= simEndMs; t += stepMs) {
                series.temp.push({ x: t, y: getCurveState(t).temp });
            }

            // 2. Dados Reais
            for(let i=0; i<realHistory.length-1; i++) {
                let start = realHistory[i];
                let end = realHistory[i+1];
                
                if (end.isRefill) {
                    // MODO: Queda Simulada
                    // Para visualização individual, aplicamos a mesma lógica de queda proporcional
                    
                    // UNIFIED
                    let currMass = start.mass;
                    // INDIVIDUAL
                    let m1 = start.raw.tq1 * (TANK_CAPACITY_SINGLE/100);
                    let m2 = start.raw.tq2 * (TANK_CAPACITY_SINGLE/100);
                    let m3 = start.raw.tq3 * (TANK_CAPACITY_SINGLE/100);

                    let currTime = start.ts;
                    
                    // Initial points - Start of simulated drop segment
                    if(currTime >= bakeStartMs) {
                         if (!isIndiv) {
                             let val = isKg ? currMass : (currMass/TOTAL_CAPACITY)*100;
                             // Break solid line
                             series.real.push({ x: currTime, y: val }); 
                             series.real.push({ x: currTime, y: null });
                             // Start dotted line
                             series.simulatedDrops.push({ x: currTime, y: val });
                         } else {
                             // Break solids
                             let v1 = isKg ? m1 : start.raw.tq1; series.real1.push({x:currTime, y:v1}); series.real1.push({x:currTime, y:null}); series.simDrops1.push({x:currTime, y:v1});
                             let v2 = isKg ? m2 : start.raw.tq2; series.real2.push({x:currTime, y:v2}); series.real2.push({x:currTime, y:null}); series.simDrops2.push({x:currTime, y:v2});
                             let v3 = isKg ? m3 : start.raw.tq3; series.real3.push({x:currTime, y:v3}); series.real3.push({x:currTime, y:null}); series.simDrops3.push({x:currTime, y:v3});
                         }
                    }

                    while(currTime < end.ts) {
                        currTime += stepMs;
                        if(currTime > end.ts) currTime = end.ts;

                        let state = getCurveState(currTime);
                        let oven = getOvenConsumption(state.temp);
                        let dropTotal = (BASE_LOAD_KG_H + oven) * (10/60);
                        
                        // Unified update
                        currMass -= dropTotal;

                        // Individual update (proportional draw)
                        let totalM = m1 + m2 + m3;
                        if (totalM > 0) {
                             m1 -= dropTotal * (m1/totalM);
                             m2 -= dropTotal * (m2/totalM);
                             m3 -= dropTotal * (m3/totalM);
                        }

                        if(currTime >= bakeStartMs) {
                             if (!isIndiv) {
                                 let val = isKg ? currMass : (currMass/TOTAL_CAPACITY)*100;
                                 series.simulatedDrops.push({ x: currTime, y: val });
                             } else {
                                 series.simDrops1.push({ x: currTime, y: isKg ? m1 : (m1/TANK_CAPACITY_SINGLE)*100 });
                                 series.simDrops2.push({ x: currTime, y: isKg ? m2 : (m2/TANK_CAPACITY_SINGLE)*100 });
                                 series.simDrops3.push({ x: currTime, y: isKg ? m3 : (m3/TANK_CAPACITY_SINGLE)*100 });
                             }
                        }
                    }
                    
                    // End of simulated drop loop (at end.ts)

                    // Create Vertical Line in the Dotted Series
                    if (!isIndiv) {
                         // Add low point (already added in loop if exact match, but safety add)
                         let lowVal = isKg ? currMass : (currMass/TOTAL_CAPACITY)*100;
                         // Add High point (Actual reading)
                         let highVal = isKg ? end.mass : end.pct;
                         series.simulatedDrops.push({ x: end.ts, y: highVal }); // This creates the vertical line up!
                         series.simulatedDrops.push({ x: end.ts, y: null });    // Break dotted line
                         
                         // Resume solid line
                         if(end.ts >= bakeStartMs) series.real.push({ x: end.ts, y: highVal });
                    } else {
                         // Individual vertical lines
                         let h1 = isKg ? end.raw.tq1*(TANK_CAPACITY_SINGLE/100) : end.raw.tq1;
                         let h2 = isKg ? end.raw.tq2*(TANK_CAPACITY_SINGLE/100) : end.raw.tq2;
                         let h3 = isKg ? end.raw.tq3*(TANK_CAPACITY_SINGLE/100) : end.raw.tq3;

                         series.simDrops1.push({ x: end.ts, y: h1 }); series.simDrops1.push({ x: end.ts, y: null });
                         series.simDrops2.push({ x: end.ts, y: h2 }); series.simDrops2.push({ x: end.ts, y: null });
                         series.simDrops3.push({ x: end.ts, y: h3 }); series.simDrops3.push({ x: end.ts, y: null });

                         if(end.ts >= bakeStartMs) {
                            series.real1.push({ x: end.ts, y: h1 });
                            series.real2.push({ x: end.ts, y: h2 });
                            series.real3.push({ x: end.ts, y: h3 });
                         }
                    }

                } else {
                    // MODO: Interpolação Linear
                    let diff = end.ts - start.ts;
                    let steps = Math.floor(diff / stepMs);
                    for(let k=0; k<=steps; k++) { 
                        let t = start.ts + (k*stepMs);
                        let progress = k/steps;
                        
                        if(t >= bakeStartMs) {
                            if(!isIndiv) {
                                let val = isKg ? 
                                    start.mass + (end.mass - start.mass) * progress :
                                    start.pct + (end.pct - start.pct) * progress;
                                series.real.push({ x: t, y: val });
                            } else {
                                // Individual Interpolation
                                let v1 = start.raw.tq1 + (end.raw.tq1 - start.raw.tq1) * progress;
                                let v2 = start.raw.tq2 + (end.raw.tq2 - start.raw.tq2) * progress;
                                let v3 = start.raw.tq3 + (end.raw.tq3 - start.raw.tq3) * progress;
                                
                                series.real1.push({ x: t, y: isKg ? v1*(TANK_CAPACITY_SINGLE/100) : v1 });
                                series.real2.push({ x: t, y: isKg ? v2*(TANK_CAPACITY_SINGLE/100) : v2 });
                                series.real3.push({ x: t, y: isKg ? v3*(TANK_CAPACITY_SINGLE/100) : v3 });
                            }
                        }
                    }
                }
            }

            // 3. Marcadores
            if (!isIndiv) {
                realHistory.forEach(pt => {
                    if(pt.ts >= bakeStartMs) {
                        let val = isKg ? pt.mass : pt.pct;
                        if (pt.isRefill) { series.refillMarkers.push({ x: pt.ts, y: val }); } 
                        else { series.markers.push({ x: pt.ts, y: val }); }
                    }
                });
            } else {
                // Individual markers logic
                realHistory.forEach(pt => {
                    if(pt.ts >= bakeStartMs) {
                        let v1 = isKg ? pt.raw.tq1*(TANK_CAPACITY_SINGLE/100) : pt.raw.tq1;
                        let v2 = isKg ? pt.raw.tq2*(TANK_CAPACITY_SINGLE/100) : pt.raw.tq2;
                        let v3 = isKg ? pt.raw.tq3*(TANK_CAPACITY_SINGLE/100) : pt.raw.tq3;
                        
                        if(pt.isRefill) {
                             series.refillMarkers1.push({x: pt.ts, y: v1});
                             series.refillMarkers2.push({x: pt.ts, y: v2});
                             series.refillMarkers3.push({x: pt.ts, y: v3});
                        } else {
                             series.markers1.push({x: pt.ts, y: v1});
                             series.markers2.push({x: pt.ts, y: v2});
                             series.markers3.push({x: pt.ts, y: v3});
                        }
                    }
                });
            }

            // 4. Projeção
            if (!pLastReal) return;
            let simTime = pLastReal.ts;
            let currentMass = pLastReal.mass;
            // Individual masses start
            let m1 = pLastReal.raw.tq1 * (TANK_CAPACITY_SINGLE/100);
            let m2 = pLastReal.raw.tq2 * (TANK_CAPACITY_SINGLE/100);
            let m3 = pLastReal.raw.tq3 * (TANK_CAPACITY_SINGLE/100);

            let lastRefillTime = lastRefillTimestamp;
            let failureDate = null;

            // Start Point
            if(!isIndiv) {
                series.projected.push({ x: simTime, y: isKg ? currentMass : pLastReal.pct });
            } else {
                series.proj1.push({ x: simTime, y: isKg ? m1 : pLastReal.raw.tq1 });
                series.proj2.push({ x: simTime, y: isKg ? m2 : pLastReal.raw.tq2 });
                series.proj3.push({ x: simTime, y: isKg ? m3 : pLastReal.raw.tq3 });
            }

            while(simTime < simEndMs) {
                // Abastecimento Futuro
                if(isAutoRefill && (simTime - lastRefillTime) >= refillIntervalMs) {
                    if(!isIndiv) {
                        let preVal = isKg ? currentMass : (currentMass/TOTAL_CAPACITY)*100;
                        series.projected.push({ x: simTime, y: preVal });
                        currentMass = (REFILL_LEVEL_PERCENT/100) * TOTAL_CAPACITY;
                        let postVal = isKg ? currentMass : REFILL_LEVEL_PERCENT;
                        series.projected.push({ x: simTime, y: postVal });
                    } else {
                        // Individual refill logic
                        // Record Pre
                        series.proj1.push({x: simTime, y: isKg ? m1 : (m1/TANK_CAPACITY_SINGLE)*100});
                        series.proj2.push({x: simTime, y: isKg ? m2 : (m2/TANK_CAPACITY_SINGLE)*100});
                        series.proj3.push({x: simTime, y: isKg ? m3 : (m3/TANK_CAPACITY_SINGLE)*100});
                        
                        // Refill
                        m1 = (REFILL_LEVEL_PERCENT/100) * TANK_CAPACITY_SINGLE;
                        m2 = (REFILL_LEVEL_PERCENT/100) * TANK_CAPACITY_SINGLE;
                        m3 = (REFILL_LEVEL_PERCENT/100) * TANK_CAPACITY_SINGLE;
                        currentMass = m1 + m2 + m3;

                        // Record Post
                        let p1 = isKg ? m1 : REFILL_LEVEL_PERCENT;
                        series.proj1.push({x: simTime, y: p1});
                        series.proj2.push({x: simTime, y: p1});
                        series.proj3.push({x: simTime, y: p1});
                    }
                    lastRefillTime = simTime;
                }

                simTime += stepMs;
                let state = getCurveState(simTime);
                let ovenLoad = getOvenConsumption(state.temp);
                let totalLoad = (BASE_LOAD_KG_H + ovenLoad) * totalFactor;
                
                let drop = totalLoad * (10/60);
                currentMass -= drop;

                if(!isIndiv) {
                    if(currentMass <= (SAFETY_LIMIT_PERCENT/100)*TOTAL_CAPACITY) {
                        currentMass = (SAFETY_LIMIT_PERCENT/100)*TOTAL_CAPACITY;
                        if(!failureDate) failureDate = new Date(simTime);
                    }
                    let val = isKg ? currentMass : (currentMass/TOTAL_CAPACITY)*100;
                    series.projected.push({ x: simTime, y: val }); 
                } else {
                     let totalM = m1 + m2 + m3;
                     if(totalM > 0) {
                         m1 -= drop * (m1/totalM);
                         m2 -= drop * (m2/totalM);
                         m3 -= drop * (m3/totalM);
                     }
                     // Check limit (assuming total system safety)
                     if((m1+m2+m3) <= (SAFETY_LIMIT_PERCENT/100)*TOTAL_CAPACITY) {
                          if(!failureDate) failureDate = new Date(simTime);
                     }
                     
                     series.proj1.push({ x: simTime, y: isKg ? m1 : (m1/TANK_CAPACITY_SINGLE)*100 });
                     series.proj2.push({ x: simTime, y: isKg ? m2 : (m2/TANK_CAPACITY_SINGLE)*100 });
                     series.proj3.push({ x: simTime, y: isKg ? m3 : (m3/TANK_CAPACITY_SINGLE)*100 });
                }

                if(failureDate && !isAutoRefill && simTime > failureDate.getTime() + (12*3600000)) break;
            }

            updateChart(series, pLastReal.ts, isKg, isIndiv);
            updateStatus(failureDate, totalFactor, isAutoRefill, simTime);
            updateLegend();
        }

        function updateStatus(failureDate, combinedFactor, isAutoRefill, finalTime) {
             // ... existing logic (shortened for brevity, same as before) ...
             // Just to refresh DOM for factor/loads
             let now = pLastReal ? pLastReal.ts : Date.now();
             
             if(now < bakeStartMs) now = bakeStartMs;
             let state = getCurveState(now);
             let oven = getOvenConsumption(state.temp);
             let total = (BASE_LOAD_KG_H + oven) * combinedFactor;
             
             const elBase = document.getElementById('eq-base');
             const elOven = document.getElementById('eq-oven');
             const elFactor = document.getElementById('eq-factor');
             
             const elOvenTemp = document.getElementById('oven-temp');
             const elTotalLoad = document.getElementById('total-load');
             const elPhase = document.getElementById('phase-name');

             if(elBase) elBase.innerText = BASE_LOAD_KG_H.toFixed(0);
             if(elOven) elOven.innerText = oven.toFixed(0);
             if(elFactor) elFactor.innerText = (combinedFactor*100).toFixed(0);
             
             if(elPhase) elPhase.innerText = state.phase;
             if(elOvenTemp) elOvenTemp.innerText = Math.round(state.temp) + "°C";
             if(elTotalLoad) elTotalLoad.innerText = total.toFixed(0) + " kg/h";
             
             // ... other updates ...
             let statusTxt = document.getElementById('system-end-status');
             let statusPn = document.getElementById('status-panel');
             if(failureDate && statusTxt) {
                 let d = failureDate;
                 statusTxt.innerText = `COLAPSO: ${d.getDate()}/${d.getMonth()+1} às ${d.getHours()}:00`;
                 statusTxt.className = "text-xl font-bold text-red-700";
                 if(statusPn) statusPn.className = "mt-4 md:mt-0 px-4 py-2 rounded-lg bg-red-100 border border-red-200 text-right";
             } else if (statusTxt) {
                 statusTxt.innerText = isAutoRefill ? "OPERAÇÃO ESTÁVEL" : "OK > 120h";
                 statusTxt.className = "text-xl font-bold text-green-700";
                 if(statusPn) statusPn.className = "mt-4 md:mt-0 px-4 py-2 rounded-lg bg-green-100 border border-green-200 text-right";
             }
        }

        function updateChart(series, transitionTs, isKg, isIndiv) {
            const ctx = document.getElementById('mainChart').getContext('2d');
            if(myChart) myChart.destroy();

            const yMax = isKg ? (isIndiv ? 4200 : 12500) : 100; // adjust max for individual view
            const critVal = isKg ? (isIndiv ? 400 : 1200) : 10;

            // Base datasets
            let datasets = [
                 {
                    label: 'Temp Forno', data: series.temp,
                    borderColor: 'rgba(239, 68, 68, 0.1)', borderWidth: 0,
                    backgroundColor: 'rgba(239, 68, 68, 0.05)', fill: true, pointRadius: 0, yAxisID: 'yTemp', order: 20
                }
            ];

            if(!isIndiv) {
                datasets.push(
                    {
                        label: 'Histórico Real', data: series.real,
                        borderColor: '#2563eb', borderWidth: 3, pointRadius: 0,
                        pointHoverRadius: 4, yAxisID: 'yLevel', tension: 0, order: 2, spanGaps: false
                    },
                    {
                        label: 'Histórico Estimado', data: series.simulatedDrops,
                        borderColor: '#3b82f6', borderDash: [5, 5], borderWidth: 2,
                        pointRadius: 0, yAxisID: 'yLevel', tension: 0, order: 3, spanGaps: false
                    },
                    {
                        label: 'Leitura Normal', data: series.markers,
                        borderColor: '#1e40af', backgroundColor: 'white', borderWidth: 2, pointRadius: 5,
                        showLine: false, yAxisID: 'yLevel', order: 1
                    },
                    {
                        label: 'Abastecimento', data: series.refillMarkers,
                        borderColor: '#166534', backgroundColor: '#22c55e', borderWidth: 2, pointRadius: 8, pointStyle: 'rectRot',
                        showLine: false, yAxisID: 'yLevel', order: 0
                    },
                    {
                        label: 'Projeção', data: series.projected,
                        borderColor: '#4f46e5', borderDash: [5, 5], borderWidth: 2,
                        pointRadius: 0, pointHoverRadius: 4, yAxisID: 'yLevel', tension: 0.1, order: 4, spanGaps: false
                    }
                );
            } else {
                // INDIVIDUAL VIEW DATASETS
                datasets.push(
                    // TQ1
                    { label: 'TQ1 Hist', data: series.real1, borderColor: '#2563eb', borderWidth: 2, pointRadius:0, yAxisID:'yLevel', tension:0, spanGaps:false },
                    { label: 'TQ1 Est', data: series.simDrops1, borderColor: '#60a5fa', borderDash:[3,3], borderWidth:1, pointRadius:0, yAxisID:'yLevel', spanGaps:false },
                    { label: 'TQ1 Proj', data: series.proj1, borderColor: '#2563eb', borderDash:[5,5], borderWidth:2, pointRadius:0, yAxisID:'yLevel', tension:0.1, spanGaps:false },
                    // TQ2
                    { label: 'TQ2 Hist', data: series.real2, borderColor: '#ea580c', borderWidth: 2, pointRadius:0, yAxisID:'yLevel', tension:0, spanGaps:false },
                    { label: 'TQ2 Est', data: series.simDrops2, borderColor: '#fdba74', borderDash:[3,3], borderWidth:1, pointRadius:0, yAxisID:'yLevel', spanGaps:false },
                    { label: 'TQ2 Proj', data: series.proj2, borderColor: '#ea580c', borderDash:[5,5], borderWidth:2, pointRadius:0, yAxisID:'yLevel', tension:0.1, spanGaps:false },
                    // TQ3
                    { label: 'TQ3 Hist', data: series.real3, borderColor: '#0d9488', borderWidth: 2, pointRadius:0, yAxisID:'yLevel', tension:0, spanGaps:false },
                    { label: 'TQ3 Est', data: series.simDrops3, borderColor: '#5eead4', borderDash:[3,3], borderWidth:1, pointRadius:0, yAxisID:'yLevel', spanGaps:false },
                    { label: 'TQ3 Proj', data: series.proj3, borderColor: '#0d9488', borderDash:[5,5], borderWidth:2, pointRadius:0, yAxisID:'yLevel', tension:0.1, spanGaps:false },
                    
                    // Markers (All tanks)
                    { label: 'TQ1 Leitura', data: series.markers1, borderColor:'#1e40af', backgroundColor:'white', borderWidth:2, pointRadius:4, showLine:false, yAxisID:'yLevel' },
                    { label: 'TQ2 Leitura', data: series.markers2, borderColor:'#c2410c', backgroundColor:'white', borderWidth:2, pointRadius:4, showLine:false, yAxisID:'yLevel' },
                    { label: 'TQ3 Leitura', data: series.markers3, borderColor:'#0f766e', backgroundColor:'white', borderWidth:2, pointRadius:4, showLine:false, yAxisID:'yLevel' },
                    
                    { label: 'TQ1 Refill', data: series.refillMarkers1, borderColor:'#166534', backgroundColor:'#22c55e', borderWidth:2, pointRadius:6, pointStyle:'rectRot', showLine:false, yAxisID:'yLevel' },
                    { label: 'TQ2 Refill', data: series.refillMarkers2, borderColor:'#166534', backgroundColor:'#22c55e', borderWidth:2, pointRadius:6, pointStyle:'rectRot', showLine:false, yAxisID:'yLevel' },
                    { label: 'TQ3 Refill', data: series.refillMarkers3, borderColor:'#166534', backgroundColor:'#22c55e', borderWidth:2, pointRadius:6, pointStyle:'rectRot', showLine:false, yAxisID:'yLevel' }
                );
            }

            myChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'nearest', axis: 'x', intersect: false },
                    scales: {
                        x: { type: 'time', min: bakeStartMs, max: simEndMs, time: { unit: 'day', displayFormats: { day: 'dd/MM' }, tooltipFormat: 'dd/MM/yyyy HH:mm' } },
                        yLevel: { type: 'linear', position: 'left', min: 0, max: yMax, title: { display: true, text: isKg ? 'Massa (kg)' : 'Nível (%)' } },
                        yTemp: { type: 'linear', position: 'right', min: 0, max: 800, grid: { drawOnChartArea: false }, title: {display:true, text:'Temp (°C)'} }
                    },
                    plugins: {
                        legend: { display: false }, // using custom legend
                        annotation: {
                            annotations: {
                                line: { type: 'line', xMin: transitionTs, xMax: transitionTs, borderColor: 'gray', borderWidth: 2, borderDash: [2,2] },
                                crit: { type: 'line', yMin: critVal, yMax: critVal, yScaleID: 'yLevel', borderColor: 'red', borderWidth: 1 }
                            }
                        },
                        tooltip: {
                            position: 'followMouse',
                            callbacks: {
                                label: function(ctx) {
                                    if (ctx.dataset.yAxisID === 'yTemp') return `Temp: ${Math.round(ctx.parsed.y)}°C`;
                                    if (ctx.parsed.y === null) return null;
                                    let val = Math.round(ctx.parsed.y);
                                    return `${ctx.dataset.label}: ${val}${isKg ? 'kg' : '%'}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        updateLegend();
        recalculateModel();
        renderEditableTable();
        runSimulation();
    </script>
</body>
</html>
